---
title: Examples
description: Real-world examples and use cases for mutation operations in Drizzle Service.
---

import { Banner } from 'fumadocs-ui/components/banner'
import { Step, Steps } from 'fumadocs-ui/components/steps'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'

## User Registration & Authentication

### Complete User Registration Flow

A comprehensive example showing user registration with validation, email verification, and profile creation.

```typescript title="User Registration Service" 
async function registerUser(userData: CreateUserRequest) {
  const [error, user] = await userService.create(
    {
      email: userData.email,
      name: userData.name,
      status: 'pending_verification'
    },
    {
      beforeAction: async (data) => { // [!code highlight]
        // Check if email is already registered
        const existing = await userService.findByField('email', data.email)
        if (existing.length > 0) {
          throw new Error('Email already registered')
        }
        
        // Validate email domain against blocked list
        await validateEmailDomain(data.email)
        
        // Check rate limiting
        await checkRegistrationRateLimit(data.email)
      }, // [!code highlight]
      afterAction: async (user) => { // [!code highlight]
        // Send verification email
        await emailService.sendVerificationEmail(user.email, user.id)
        
        // Create user profile with defaults
        await profileService.create({
          userId: user.id,
          preferences: getDefaultPreferences(),
          avatar: generateDefaultAvatar(user.name)
        })
        
        // Log registration event
        await analytics.track('user_registered', {
          userId: user.id,
          email: user.email,
          source: userData.source
        })
        
        // Add to welcome email sequence
        await marketingService.addToWelcomeSequence(user.email)
      }, // [!code highlight]
      onError: async (error) => {
        await logger.error('User registration failed', {
          email: userData.email,
          error: error.message,
          stack: error.stack
        })
      }
    }
  )
  
  if (error) { // [!code highlight]
    throw new Error(`Registration failed: ${error.message}`) // [!code highlight]
  } // [!code highlight]
  
  return user
}
```

### Email Verification Update

```typescript title="Email Verification Service"
async function verifyUserEmail(userId: number, verificationToken: string) {
  // Verify token first
  const isValidToken = await verificationService.validateToken(userId, verificationToken) // [!code highlight]
  if (!isValidToken) { // [!code highlight]
    throw new Error('Invalid or expired verification token') // [!code highlight]
  } // [!code highlight]

  const [error, user] = await userService.update(
    userId,
    { 
      status: 'active', // [!code highlight]
      emailVerifiedAt: new Date() // [!code highlight]
    },
      {
        beforeAction: async (data) => {
          // Log verification attempt
          await auditService.log('email_verification_attempt', {
            userId,
            timestamp: new Date()
          })
        },
        afterAction: async (updatedUser) => { // [!code highlight]
          // Clean up verification tokens
          await verificationService.deleteTokensForUser(userId)
          
          // Send welcome email
          await emailService.sendWelcomeEmail(updatedUser.email)
          
          // Grant initial credits or benefits
          await rewardsService.grantWelcomeBonus(userId)
          
          // Update user analytics
          await analytics.identify(userId, {
            email_verified: true,
            verified_at: updatedUser.emailVerifiedAt
          })
        } // [!code highlight]
      }
    )

    if (error) { // [!code highlight]
      throw new Error(`Email verification failed: ${error.message}`) // [!code highlight]
    } // [!code highlight]

    return user
  }
  ```

## E-commerce Operations

### Order Creation with Inventory Check

```typescript title="Order Creation Service"
async function createOrder(orderData: CreateOrderRequest, userId: number) {
  const [error, order] = await orderService.create(
    {
      userId,
      items: orderData.items,
      totalAmount: orderData.totalAmount,
      status: 'pending',
      shippingAddress: orderData.shippingAddress
    },
    {
      beforeAction: async (data) => { // [!code highlight]
        // Validate inventory for all items
        for (const item of data.items) { // [!code highlight]
          const product = await productService.findById(item.productId)
          if (!product) {
            throw new Error(`Product ${item.productId} not found`)
          }
          
          if (product.stock < item.quantity) { // [!code highlight]
            throw new Error(`Insufficient stock for ${product.name}`) // [!code highlight]
          } // [!code highlight]
        } // [!code highlight]
          
          // Validate user's payment method
          await paymentService.validatePaymentMethod(userId, orderData.paymentMethodId)
          
          // Check user credit limit if applicable
          if (orderData.paymentMethod === 'credit') {
            await creditService.checkCreditLimit(userId, data.totalAmount)
          }
        },
        afterAction: async (order) => {
          // Reserve inventory
          await Promise.all(
            order.items.map(item =>
              inventoryService.reserveStock(item.productId, item.quantity, order.id)
            )
          )
          
          // Process payment
          const paymentResult = await paymentService.processPayment({
            orderId: order.id,
            amount: order.totalAmount,
            paymentMethodId: orderData.paymentMethodId
          })
          
          if (paymentResult.success) {
            // Update order status
            await orderService.update(order.id, { 
              status: 'confirmed',
              paymentId: paymentResult.paymentId
            })
            
            // Send confirmation email
            await emailService.sendOrderConfirmation(userId, order)
            
            // Create shipping label
            await shippingService.createLabel(order)
          } else {
            // Release reserved inventory
            await inventoryService.releaseReservation(order.id)
            throw new Error('Payment processing failed')
          }
        },
        onError: async (error) => {
          // Release any reserved inventory
          await inventoryService.releaseReservation(orderData.tempOrderId)
          
          // Log the error with context
          await logger.error('Order creation failed', {
            userId,
            items: orderData.items,
            error: error.message
          })
        }
      }
    )

    if (error) {
      throw new Error(`Order creation failed: ${error.message}`)
    }

    return order
  }
  ```

### Product Update with Price History

```typescript title="Price Update Service"
async function updateProductPrice(productId: number, newPrice: number, updatedBy: number) {
  const [error, product] = await productService.update(
    productId,
    { price: newPrice }, // [!code highlight]
    {
      beforeAction: async (data) => { // [!code highlight]
        // Get current product for price comparison
        const currentProduct = await productService.findById(productId)
        if (!currentProduct) {
          throw new Error('Product not found')
        }
        
        // Validate price change is reasonable
        const priceChange = Math.abs(newPrice - currentProduct.price) / currentProduct.price // [!code highlight]
        if (priceChange > 0.5) { // 50% change // [!code highlight]
          throw new Error('Price change exceeds maximum allowed threshold') // [!code highlight]
        } // [!code highlight]
        
        // Check user permissions for price updates
        const hasPermission = await permissionService.canUpdatePrice(updatedBy, productId)
        if (!hasPermission) {
          throw new Error('Insufficient permissions to update price')
        }
      }, // [!code highlight]
      afterAction: async (updatedProduct) => { // [!code highlight]
        // Record price history
        await priceHistoryService.create({
          productId: updatedProduct.id,
          oldPrice: currentProduct.price,
          newPrice: updatedProduct.price,
          changedBy: updatedBy,
          changeReason: 'manual_update',
          timestamp: new Date()
        })
        
        // Update search index with new price
        await searchService.updateProduct(updatedProduct)
        
        // Notify customers with price alerts
        await notificationService.notifyPriceChange(productId, updatedProduct.price)
        
        // Invalidate product cache
        await cache.delete(`product:${productId}`)
        await cache.delete(`product:price:${productId}`)
      } // [!code highlight]
    }
  )

  if (error) { // [!code highlight]
    throw new Error(`Price update failed: ${error.message}`) // [!code highlight]
  } // [!code highlight]

  return product
}
```

## Content Management

### Blog Post Creation with SEO

  ```typescript
  async function createBlogPost(postData: CreatePostRequest, authorId: number) {
    const [error, post] = await postService.create(
      {
        title: postData.title,
        content: postData.content,
        authorId,
        status: 'draft',
        tags: postData.tags,
        featuredImage: postData.featuredImage
      },
      {
        beforeAction: async (data) => {
          // Validate content for quality
          const contentAnalysis = await contentService.analyzeQuality(data.content)
          if (contentAnalysis.score < 0.7) {
            throw new Error('Content quality score too low')
          }
          
          // Check for duplicate titles
          const existingPost = await postService.findByField('title', data.title)
          if (existingPost.length > 0) {
            throw new Error('A post with this title already exists')
          }
          
          // Validate author permissions
          const canPublish = await permissionService.canCreatePost(authorId)
          if (!canPublish) {
            throw new Error('Author does not have permission to create posts')
          }
        },
        afterAction: async (post) => {
          // Generate SEO metadata
          const seoData = await seoService.generateMetadata(post)
          await postMetaService.create({
            postId: post.id,
            metaTitle: seoData.title,
            metaDescription: seoData.description,
            keywords: seoData.keywords
          })
          
          // Generate and upload featured image if not provided
          if (!post.featuredImage) {
            const generatedImage = await imageService.generateFeaturedImage(post.title)
            await postService.update(post.id, { featuredImage: generatedImage.url })
          }
          
          // Process content for internal links
          await linkService.processInternalLinks(post.id, post.content)
          
          // Schedule social media posts if published
          if (post.status === 'published') {
            await socialMediaService.schedulePost(post)
          }
          
          // Update author statistics
          await authorService.updateStats(authorId, { postsCreated: 1 })
        }
      }
    )

    if (error) {
      throw new Error(`Post creation failed: ${error.message}`)
    }

    return post
  }
  ```

### Comment Moderation

  ```typescript
  async function moderateComment(commentId: number, action: 'approve' | 'reject', moderatorId: number) {
    const status = action === 'approve' ? 'approved' : 'rejected'
    
    const [error, comment] = await commentService.update(
      commentId,
      { 
        status,
        moderatedBy: moderatorId,
        moderatedAt: new Date()
      },
      {
        beforeAction: async (data) => {
          // Get current comment
          const comment = await commentService.findById(commentId)
          if (!comment) {
            throw new Error('Comment not found')
          }
          
          if (comment.status !== 'pending') {
            throw new Error('Comment has already been moderated')
          }
          
          // Check moderator permissions
          const canModerate = await permissionService.canModerate(moderatorId)
          if (!canModerate) {
            throw new Error('Insufficient permissions for moderation')
          }
        },
        afterAction: async (comment) => {
          if (action === 'approve') {
            // Notify post author of new approved comment
            await notificationService.notifyCommentApproved(comment.postId, comment.authorId)
            
            // Update comment count on post
            await postService.incrementCommentCount(comment.postId)
            
            // Award points to commenter
            await pointsService.awardPoints(comment.authorId, 'comment_approved', 5)
          } else {
            // Log rejection reason
            await moderationLogService.create({
              commentId: comment.id,
              action: 'rejected',
              moderatorId,
              reason: 'Policy violation',
              timestamp: new Date()
            })
            
            // Notify commenter of rejection
            await notificationService.notifyCommentRejected(comment.authorId)
          }
          
          // Update moderation queue statistics
          await moderationService.updateStats(moderatorId, action)
        }
      }
    )

    if (error) {
      throw new Error(`Comment moderation failed: ${error.message}`)
    }

    return comment
  }
  ```

## User Account Management

### Profile Update with Image Processing

  ```typescript
  async function updateUserProfile(userId: number, profileData: UpdateProfileRequest) {
    const [error, user] = await userService.update(
      userId,
      {
        name: profileData.name,
        bio: profileData.bio,
        location: profileData.location,
        website: profileData.website
      },
      {
        beforeAction: async (data) => {
          // Validate profile data
          if (data.website && !isValidUrl(data.website)) {
            throw new Error('Invalid website URL')
          }
          
          if (data.bio && data.bio.length > 500) {
            throw new Error('Bio must be less than 500 characters')
          }
          
          // Check for inappropriate content
          const moderationResult = await contentModerationService.check(data.bio)
          if (!moderationResult.isAppropriate) {
            throw new Error('Profile content violates community guidelines')
          }
        },
        afterAction: async (updatedUser) => {
          // Process avatar upload if provided
          if (profileData.avatar) {
            const processedAvatar = await imageService.processAvatar(profileData.avatar)
            await userService.update(userId, { avatar: processedAvatar.url })
          }
          
          // Update search index
          await searchService.updateUserProfile(updatedUser)
          
          // Invalidate user cache
          await cache.delete(`user:${userId}`)
          await cache.delete(`user:profile:${userId}`)
          
          // Log profile update
          await auditService.log('profile_updated', {
            userId,
            changes: Object.keys(profileData),
            timestamp: new Date()
          })
          
          // Update user completeness score
          await userService.updateCompletenessScore(userId)
        }
      }
    )

    if (error) {
      throw new Error(`Profile update failed: ${error.message}`)
    }

    return user
  }
  ```

### Account Deactivation with Cleanup

  ```typescript
  async function deactivateUserAccount(userId: number, reason: string, deactivatedBy?: number) {
    const result = await userService.delete(
      userId,
      {
        beforeAction: async (id) => {
          // Archive user data
          const user = await userService.findById(id)
          if (!user) {
            throw new Error('User not found')
          }
          
          // Create data archive
          await archiveService.create({
            entityType: 'user',
            entityId: id,
            data: user,
            reason,
            archivedBy: deactivatedBy,
            archivedAt: new Date()
          })
          
          // Check for active subscriptions
          const activeSubscriptions = await subscriptionService.getActiveByUserId(id)
          if (activeSubscriptions.length > 0) {
            throw new Error('Cannot deactivate user with active subscriptions')
          }
        },
        afterAction: async (id) => {
          // Cancel all user sessions
          await sessionService.cancelAllForUser(id)
          
          // Cancel scheduled emails
          await emailService.cancelScheduledForUser(id)
          
          // Remove from mailing lists
          await mailingService.unsubscribeUser(id)
          
          // Anonymize user content
          await contentService.anonymizeUserContent(id)
          
          // Update analytics
          await analytics.track('user_deactivated', {
            userId: id,
            reason,
            deactivatedBy: deactivatedBy || 'self'
          })
          
          // Notify relevant teams
          await notificationService.notifyUserDeactivation(id, reason)
        }
      }
    )

    if (!result.success) {
      throw new Error('Account deactivation failed')
    }

    return result
  }
  ```

## Error Handling Patterns

### Comprehensive Error Handling

```typescript title="Robust User Update with Error Handling"
async function robustUserUpdate(userId: number, updateData: UpdateUserData) {
  const [error, user] = await userService.update(
    userId,
    updateData,
    {
      beforeAction: async (data) => { // [!code highlight]
        // Multiple validation layers
        await validateUserPermissions(userId) // [!code highlight]
        await validateDataIntegrity(data) // [!code highlight]
        await checkBusinessRules(data) // [!code highlight]
      }, // [!code highlight]
      afterAction: async (user) => {
        // Success cleanup and notifications
        await updateRelatedSystems(user)
        await notifyStakeholders(user)
      },
      onError: async (error) => { // [!code highlight]
        // Comprehensive error handling
        await logError(error, { userId, updateData }) // [!code highlight]
        await notifyErrorTeam(error) // [!code highlight]
        await rollbackPartialChanges(userId) // [!code highlight]
      } // [!code highlight]
    }
  )

  if (error) { // [!code highlight]
    // Client-friendly error messages
    const clientError = mapToClientError(error) // [!code highlight]
    throw new Error(clientError.message) // [!code highlight]
  } // [!code highlight]

  return user
}
```

### Retry Logic with Exponential Backoff

```typescript title="User Creation with Retry Logic"
async function createUserWithRetry(userData: CreateUserData, maxRetries = 3) {
  let lastError: Error

  for (let attempt = 1; attempt <= maxRetries; attempt++) { // [!code highlight]
    try {
      const [error, user] = await userService.create(userData)
      
      if (error) {
        // Don't retry validation errors
        if (isValidationError(error)) { // [!code highlight]
          throw error // [!code highlight]
        } // [!code highlight]
        
        lastError = error
        
        // Exponential backoff
        const delay = Math.pow(2, attempt) * 1000 // [!code highlight]
        await new Promise(resolve => setTimeout(resolve, delay)) // [!code highlight]
        continue
      }

      return user
    } catch (error) {
      lastError = error as Error
      
      if (attempt === maxRetries) {
        break
      }
      
      // Wait before retry
      const delay = Math.pow(2, attempt) * 1000 // [!code highlight]
      await new Promise(resolve => setTimeout(resolve, delay)) // [!code highlight]
    }
  }

  throw new Error(`Failed after ${maxRetries} attempts: ${lastError.message}`) // [!code highlight]
}
```

## Soft Delete and Restore Operations

### Type-Safe Soft Delete Configuration

Examples showing different field types and their type-safe configurations:

<Tabs items={["Boolean Field", "Enum Status", "Timestamp Field"]}>
  <Tab value="Boolean Field">
    ```typescript title="Boolean Soft Delete Configuration"
    // Schema definition
    export const posts = pgTable('posts', {
      id: serial('id').primaryKey(),
      title: text('title').notNull(),
      content: text('content').notNull(),
      isDeleted: boolean('is_deleted').default(false).notNull(),
      createdAt: timestamp('created_at').defaultNow().notNull(),
      updatedAt: timestamp('updated_at').defaultNow().notNull(),
    })

    // Service configuration
    const postService = drizzleService.pg(db)(posts, {
      soft: {
        field: 'isDeleted',
        deletedValue: true,
        // notDeletedValue is optional for boolean fields (defaults to false)
      }
    })

    // Usage
    async function managePost() {
      // Create a post
      const [createError, post] = await postService.create({
        title: 'My Blog Post',
        content: 'Post content here...'
      })

      if (createError) throw createError

      // Soft delete the post
      const deleteResult = await postService.delete(post.id)
      console.log(deleteResult.success) // true

      // Restore the post
      const restoreResult = await postService.restore(post.id)
      console.log(restoreResult.success) // true
    }
    ```
  </Tab>
  <Tab value="Enum Status">
    ```typescript title="Enum Status Soft Delete Configuration"
    // Schema definition
    const userStatusEnum = pgEnum('user_status', ['active', 'inactive', 'deleted', 'banned'])

    export const users = pgTable('users', {
      id: serial('id').primaryKey(),
      email: text('email').notNull().unique(),
      name: text('name').notNull(),
      status: userStatusEnum('status').default('active').notNull(),
      createdAt: timestamp('created_at').defaultNow().notNull(),
      updatedAt: timestamp('updated_at').defaultNow().notNull(),
    })

    // Service configuration
    const userService = drizzleService.pg(db)(users, {
      soft: {
        field: 'status',
        deletedValue: 'deleted',
        notDeletedValue: 'active' // Required for non-boolean fields
      }
    })

    // Usage
    async function manageUser(userId: number) {
      // Soft delete user (sets status to 'deleted')
      const deleteResult = await userService.delete(userId, {
        beforeAction: async (user) => {
          console.log(`Deactivating user: ${user.name}`)
          // Send email notification, cleanup sessions, etc.
        }
      })

      if (deleteResult.success) {
        console.log('User soft deleted successfully')
      }

      // Restore user (sets status back to 'active')
      const restoreResult = await userService.restore(userId, {
        beforeAction: async (user) => {
          console.log(`Restoring user: ${user.name}`)
          // Send welcome back email, reactivate services, etc.
        }
      })

      if (restoreResult.success) {
        console.log('User restored successfully')
      }
    }
    ```
  </Tab>
  <Tab value="Timestamp Field">
    ```typescript title="Timestamp Soft Delete Configuration"
    import type { SoftDeleteTimestampMarker } from 'drizzle-service'

    // Schema definition
    export const orders = pgTable('orders', {
      id: serial('id').primaryKey(),
      userId: integer('user_id').notNull().references(() => users.id),
      total: decimal('total', { precision: 10, scale: 2 }).notNull(),
      deletedAt: timestamp('deleted_at'),
      createdAt: timestamp('created_at').defaultNow().notNull(),
      updatedAt: timestamp('updated_at').defaultNow().notNull(),
    })

    // Service configuration with special marker
    const orderService = drizzleService.pg(db)(orders, {
      soft: {
        field: 'deletedAt',
        deletedValue: 'NOT_NULL' as SoftDeleteTimestampMarker,
        // notDeletedValue defaults to null for timestamp fields
      }
    })

    // Alternative: Using explicit current timestamp
    const orderServiceAlt = drizzleService.pg(db)(orders, {
      soft: {
        field: 'deletedAt',
        deletedValue: new Date(), // Uses current timestamp when deleting
        notDeletedValue: null
      }
    })

    // Usage
    async function manageOrder(orderId: number) {
      // Soft delete order (sets deletedAt to current timestamp)
      const deleteResult = await orderService.delete(orderId, {
        beforeAction: async (order) => {
          // Cancel payment, notify customer, etc.
          console.log(`Cancelling order ${order.id} for user ${order.userId}`)
        }
      })

      if (deleteResult.success) {
        console.log('Order cancelled successfully')
      }

      // Restore order (sets deletedAt back to null)
      const restoreResult = await orderService.restore(orderId, {
        beforeAction: async (order) => {
          // Reactivate payment, notify customer, etc.
          console.log(`Restoring order ${order.id}`)
        }
      })

      if (restoreResult.success) {
        console.log('Order restored successfully')
      }
    }
    ```
  </Tab>
</Tabs>

### Complete Soft Delete Workflow

A comprehensive example showing a complete soft delete workflow with audit logging:

```typescript title="Complete Soft Delete Workflow"
// Audit log schema
export const auditLogs = pgTable('audit_logs', {
  id: serial('id').primaryKey(),
  entityType: text('entity_type').notNull(),
  entityId: text('entity_id').notNull(),
  action: text('action').notNull(), // 'soft_delete', 'restore', 'hard_delete'
  userId: integer('user_id').references(() => users.id),
  reason: text('reason'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
})

// Service with audit logging
const auditService = drizzleService.pg(db)(auditLogs)

// Enhanced user service with audit logging
const userServiceWithAudit = drizzleService.pg(db)(users, {
  soft: {
    field: 'status',
    deletedValue: 'deleted',
    notDeletedValue: 'active'
  },
  override: (baseMethods) => ({
    delete: async (id, hooks) => {
      const result = await baseMethods.delete(id, {
        ...hooks,
        afterAction: async (user) => {
          // Log the soft delete
          await auditService.create({
            entityType: 'user',
            entityId: id.toString(),
            action: 'soft_delete',
            userId: getCurrentUserId(), // Your auth context
            reason: 'User requested account deletion'
          })
          
          if (hooks?.afterAction) await hooks.afterAction(user)
        }
      })
      return result
    },
    
    restore: async (id, hooks) => {
      const result = await baseMethods.restore(id, {
        ...hooks,
        afterAction: async (user) => {
          // Log the restore
          await auditService.create({
            entityType: 'user',
            entityId: id.toString(),
            action: 'restore',
            userId: getCurrentUserId(),
            reason: 'Account restoration requested'
          })
          
          if (hooks?.afterAction) await hooks.afterAction(user)
        }
      })
      return result
    }
  })
})

// Helper function to get current user (implement based on your auth)
function getCurrentUserId(): number {
  // Return current authenticated user ID
  return 1 // placeholder
}
```