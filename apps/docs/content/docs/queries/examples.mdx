---
title: Examples
description: Real-world examples and use cases for query operations in Drizzle Service.
---

import { Banner } from 'fumadocs-ui/components/banner'
import { Callout } from 'fumadocs-ui/components/callout'
import { Step, Steps } from 'fumadocs-ui/components/steps'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'

# Query Examples

Real-world examples demonstrating how to use Drizzle Service query operations effectively in different scenarios.

## E-commerce Platform

### Product Catalog with Filtering

Search products with multiple filters, categories, and pagination.

```typescript title="Product Search Service"
import { and, or, eq, gt, like, between } from 'drizzle-orm'

async function searchProducts(searchParams: ProductSearchParams) {
  const { category, priceRange, search, page = 1, sortBy = 'relevance' } = searchParams
  
  // Build dynamic conditions
  const conditions = [
    eq(products.status, 'active'), // [!code highlight]
    eq(products.isVisible, true) // [!code highlight]
  ]
  
  if (category) {
    conditions.push(eq(products.categoryId, category)) // [!code highlight]
  }
  
  if (priceRange) {
    conditions.push(
      between(products.price, priceRange.min, priceRange.max) // [!code highlight]
    )
  }
  
  if (search) {
    conditions.push(
      or( // [!code highlight]
        like(products.name, `%${search}%`), // [!code highlight]
        like(products.description, `%${search}%`), // [!code highlight]
        like(products.tags, `%${search}%`) // [!code highlight]
      ) // [!code highlight]
    )
  }
  
  const orderBy = getOrderByClause(sortBy) // [!code highlight]
  
  return await productService.findAll({
    custom: and(...conditions), // [!code highlight]
    relations: [
      {
        table: categories,
        type: 'inner',
        sql: eq(products.categoryId, categories.id)
      },
      {
        table: productImages,
        type: 'left',
        sql: and(
          eq(products.id, productImages.productId),
          eq(productImages.isPrimary, true)
        )
      }
    ],
    orderBy,
    page,
    limit: 24,
    parse: (data) => data.map(row => ({ // [!code highlight]
      ...row.products, // [!code highlight]
      category: row.categories, // [!code highlight]
      primaryImage: row.productImages // [!code highlight]
    })) // [!code highlight]
  })
}

function getOrderByClause(sortBy: string) { // [!code highlight]
  switch (sortBy) { // [!code highlight]
    case 'price_low': return { price: 'asc' as const } // [!code highlight]
    case 'price_high': return { price: 'desc' as const } // [!code highlight]
    case 'newest': return { createdAt: 'desc' as const } // [!code highlight]
    case 'rating': return { averageRating: 'desc' as const } // [!code highlight]
    default: return { featured: 'desc' as const, createdAt: 'desc' as const } // [!code highlight]
  } // [!code highlight]
} // [!code highlight]
```

### Customer Order History

Retrieve customer orders with related data and pagination.

```typescript title="Order History Service"
async function getCustomerOrderHistory(customerId: number, page = 1) {
  return await orderService.findBy(
    { customerId }, // [!code highlight]
    {
      relations: [
        {
          table: orderItems,
          type: 'left',
          sql: eq(orders.id, orderItems.orderId)
        },
        {
          table: products,
          type: 'left',
          sql: eq(orderItems.productId, products.id)
        },
        {
          table: shippingAddresses,
          type: 'left',
          sql: eq(orders.shippingAddressId, shippingAddresses.id)
        }
      ],
      orderBy: { createdAt: 'desc' }, // [!code highlight]
      page,
      limit: 10,
      parse: (data) => { // [!code highlight]
        const ordersMap = new Map() // [!code highlight]
        
        data.forEach(row => { // [!code highlight]
          const orderId = row.orders.id // [!code highlight]
          
          if (!ordersMap.has(orderId)) { // [!code highlight]
            ordersMap.set(orderId, { // [!code highlight]
              ...row.orders, // [!code highlight]
              items: [], // [!code highlight]
              shippingAddress: row.shippingAddresses // [!code highlight]
            }) // [!code highlight]
          } // [!code highlight]
          
          const order = ordersMap.get(orderId) // [!code highlight]
          if (row.orderItems && row.products) { // [!code highlight]
            order.items.push({ // [!code highlight]
              ...row.orderItems, // [!code highlight]
              product: row.products // [!code highlight]
            }) // [!code highlight]
          } // [!code highlight]
        }) // [!code highlight]
        
        return Array.from(ordersMap.values()) // [!code highlight]
      } // [!code highlight]
    }
  )
}
```

### Inventory Management

Check product availability and low stock alerts.

```typescript title="Inventory Service"
async function getLowStockProducts(threshold = 10) {
  return await productService.findAll({
    custom: and( // [!code highlight]
      eq(products.trackInventory, true), // [!code highlight]
      gt(products.stock, 0), // [!code highlight]
      gt(threshold, products.stock) // [!code highlight]
    ), // [!code highlight]
    relations: [{
      table: categories,
      type: 'inner',
      sql: eq(products.categoryId, categories.id)
    }],
    orderBy: { stock: 'asc' }, // [!code highlight]
    parse: (data) => data.map(row => ({
      ...row.products,
      category: row.categories,
      stockStatus: getStockStatus(row.products.stock, threshold) // [!code highlight]
    }))
  })
}

function getStockStatus(stock: number, threshold: number) { // [!code highlight]
  if (stock === 0) return 'out_of_stock' // [!code highlight]
  if (stock <= threshold * 0.5) return 'critical' // [!code highlight]
  if (stock <= threshold) return 'low' // [!code highlight]
  return 'in_stock' // [!code highlight]
} // [!code highlight]
```

## Content Management System

### Blog Post Listing with Authors

Retrieve published blog posts with author information and metadata.

```typescript title="Blog Service"
async function getPublishedPosts(options: BlogListOptions = {}) {
  const { category, author, tag, featured, page = 1 } = options
  
  const conditions = [
    eq(posts.status, 'published'), // [!code highlight]
    gt(posts.publishedAt, new Date(0)) // [!code highlight]
  ]
  
  if (category) {
    conditions.push(eq(posts.categoryId, category)) // [!code highlight]
  }
  
  if (author) {
    conditions.push(eq(posts.authorId, author)) // [!code highlight]
  }
  
  if (tag) {
    conditions.push(like(posts.tags, `%${tag}%`)) // [!code highlight]
  }
  
  if (featured !== undefined) {
    conditions.push(eq(posts.isFeatured, featured)) // [!code highlight]
  }
  
  return await postService.findAll({
    custom: and(...conditions), // [!code highlight]
    relations: [
      {
        table: users,
        type: 'inner',
        sql: eq(posts.authorId, users.id)
      },
      {
        table: categories,
        type: 'left',
        sql: eq(posts.categoryId, categories.id)
      }
    ],
    orderBy: { publishedAt: 'desc' }, // [!code highlight]
    page,
    limit: 12,
    parse: (data) => data.map(row => ({ // [!code highlight]
      ...row.posts, // [!code highlight]
      author: { // [!code highlight]
        id: row.users.id, // [!code highlight]
        name: row.users.name, // [!code highlight]
        avatar: row.users.avatar, // [!code highlight]
        bio: row.users.bio // [!code highlight]
      }, // [!code highlight]
      category: row.categories // [!code highlight]
    })) // [!code highlight]
  })
}
```

### Comment Moderation Queue

Find comments pending moderation with context.

```typescript title="Comment Moderation Service"
async function getModerationQueue(status: 'pending' | 'flagged' = 'pending') {
  return await commentService.findBy(
    { status }, // [!code highlight]
    {
      relations: [
        {
          table: posts,
          type: 'inner',
          sql: eq(comments.postId, posts.id)
        },
        {
          table: users,
          type: 'left',
          sql: eq(comments.authorId, users.id)
        }
      ],
      orderBy: { createdAt: 'asc' }, // Oldest first for FIFO processing
      parse: (data) => data.map(row => ({ // [!code highlight]
        ...row.comments, // [!code highlight]
        post: { // [!code highlight]
          id: row.posts.id, // [!code highlight]
          title: row.posts.title, // [!code highlight]
          slug: row.posts.slug // [!code highlight]
        }, // [!code highlight]
        author: row.users ? { // [!code highlight]
          id: row.users.id, // [!code highlight]
          name: row.users.name, // [!code highlight]
          email: row.users.email // [!code highlight]
        } : null // [!code highlight]
      })) // [!code highlight]
    }
  )
}
```

### SEO Analytics Dashboard

Analyze content performance and SEO metrics.

```typescript title="SEO Analytics Service"
async function getContentAnalytics(dateRange: DateRange) {
  // Get top performing posts by views
  const topPosts = await postService.findAll({
    custom: and( // [!code highlight]
      eq(posts.status, 'published'), // [!code highlight]
      between(posts.publishedAt, dateRange.start, dateRange.end) // [!code highlight]
    ), // [!code highlight]
    orderBy: { viewCount: 'desc' }, // [!code highlight]
    limit: 10,
    relations: [{
      table: users,
      type: 'inner',
      sql: eq(posts.authorId, users.id)
    }],
    parse: (data) => data.map(row => ({ // [!code highlight]
      ...row.posts, // [!code highlight]
      author: row.users.name, // [!code highlight]
      engagementRate: calculateEngagementRate(row.posts) // [!code highlight]
    })) // [!code highlight]
  })
  
  // Get posts needing SEO attention
  const seoIssues = await postService.findAll({
    custom: and( // [!code highlight]
      eq(posts.status, 'published'), // [!code highlight]
      or( // [!code highlight]
        eq(posts.metaDescription, ''), // [!code highlight]
        eq(posts.focusKeyword, ''), // [!code highlight]
        gt(sql`LENGTH(${posts.title})`, 60) // [!code highlight]
      ) // [!code highlight]
    ), // [!code highlight]
    orderBy: { viewCount: 'desc' }
  })
  
  return { topPosts, seoIssues }
}

function calculateEngagementRate(post: any) { // [!code highlight]
  const { viewCount, commentCount, shareCount } = post // [!code highlight]
  return viewCount > 0 ? (commentCount + shareCount) / viewCount : 0 // [!code highlight]
} // [!code highlight]
```

## User Management & Analytics

### User Activity Dashboard

Track user engagement and activity patterns.

```typescript title="User Analytics Service"
async function getUserActivityReport(timeframe: 'day' | 'week' | 'month' = 'week') {
  const startDate = getStartDate(timeframe) // [!code highlight]
  
  // Active users in timeframe
  const activeUsers = await userService.findAll({
    custom: and( // [!code highlight]
      eq(users.status, 'active'), // [!code highlight]
      gt(users.lastLoginAt, startDate) // [!code highlight]
    ), // [!code highlight]
    orderBy: { lastLoginAt: 'desc' },
    limit: 100,
    parse: (data) => data.map(user => ({ // [!code highlight]
      ...user, // [!code highlight]
      activityScore: calculateActivityScore(user, timeframe) // [!code highlight]
    })) // [!code highlight]
  })
  
  // User registration trends
  const newUsers = await userService.findAll({
    custom: gt(users.createdAt, startDate), // [!code highlight]
    orderBy: { createdAt: 'desc' }
  })
  
  // Engagement metrics by user type
  const engagementByRole = await Promise.all([
    getUserEngagementByRole('admin', startDate),
    getUserEngagementByRole('moderator', startDate),
    getUserEngagementByRole('user', startDate)
  ])
  
  return {
    activeUsers,
    newUsers,
    engagementByRole,
    summary: {
      totalActive: activeUsers.length,
      totalNew: newUsers.length,
      averageActivityScore: activeUsers.reduce((sum, u) => sum + u.activityScore, 0) / activeUsers.length
    }
  }
}

async function getUserEngagementByRole(role: string, startDate: Date) { // [!code highlight]
  return await userService.findBy( // [!code highlight]
    { role }, // [!code highlight]
    { // [!code highlight]
      custom: gt(users.lastLoginAt, startDate), // [!code highlight]
      parse: (data) => ({ // [!code highlight]
        role, // [!code highlight]
        count: data.length, // [!code highlight]
        avgSessionDuration: data.reduce((sum, u) => sum + (u.avgSessionDuration || 0), 0) / data.length // [!code highlight]
      }) // [!code highlight]
    } // [!code highlight]
  ) // [!code highlight]
} // [!code highlight]
```

### Multi-tenant User Management

Handle user queries in multi-tenant applications.

```typescript title="Tenant User Service"
async function getTenantUsers(tenantId: string, filters: UserFilters = {}) {
  const { role, status, department, page = 1 } = filters
  
  const criteria: Partial<User> = {} // [!code highlight]
  
  if (role) criteria.role = role // [!code highlight]
  if (status) criteria.status = status // [!code highlight]
  if (department) criteria.department = department // [!code highlight]
  
  return await userService.findBy(
    criteria,
    {
      workspace: { // [!code highlight]
        field: 'tenantId', // [!code highlight]
        value: tenantId // [!code highlight]
      }, // [!code highlight]
      relations: [{
        table: userProfiles,
        type: 'left',
        sql: eq(users.id, userProfiles.userId)
      }],
      orderBy: { name: 'asc' },
      page,
      limit: 25,
      parse: (data) => data.map(row => ({ // [!code highlight]
        ...row.users, // [!code highlight]
        profile: row.userProfiles // [!code highlight]
      })) // [!code highlight]
    }
  )
}

// Get tenant usage statistics
async function getTenantUsageStats(tenantId: string) {
  const [totalUsers, activeUsers, adminUsers] = await Promise.all([
    userService.count(
      {},
      { workspace: { field: 'tenantId', value: tenantId } } // [!code highlight]
    ),
    userService.count(
      { status: 'active' },
      { workspace: { field: 'tenantId', value: tenantId } } // [!code highlight]
    ),
    userService.count(
      { role: 'admin' },
      { workspace: { field: 'tenantId', value: tenantId } } // [!code highlight]
    )
  ])
  
  return { totalUsers, activeUsers, adminUsers }
}
```

## Advanced Pagination Patterns

### Infinite Scroll with Cursor Pagination

Implement efficient infinite scroll for large datasets.

```typescript title="Infinite Scroll Service"
class InfiniteScrollService {
  private lastCursor: Date | null = null
  private hasMore = true
  
  async loadNextPage(limit = 20) { // [!code highlight]
    if (!this.hasMore) return { items: [], hasMore: false } // [!code highlight]
    
    const result = await postService.findWithCursor({
      cursor: this.lastCursor, // [!code highlight]
      limit,
      orderBy: { createdAt: 'desc' },
      custom: eq(posts.status, 'published'),
      relations: [{
        table: users,
        type: 'inner',
        sql: eq(posts.authorId, users.id)
      }],
      parse: (data) => data.map(row => ({ // [!code highlight]
        ...row.posts, // [!code highlight]
        author: row.users.name // [!code highlight]
      })) // [!code highlight]
    })
    
    this.lastCursor = result.nextCursor // [!code highlight]
    this.hasMore = result.pagination.hasNext // [!code highlight]
    
    return {
      items: result.items,
      hasMore: this.hasMore
    }
  }
  
  reset() { // [!code highlight]
    this.lastCursor = null // [!code highlight]
    this.hasMore = true // [!code highlight]
  } // [!code highlight]
}
```

### Search with Faceted Filters

Implement search functionality with faceted filtering options.

```typescript title="Faceted Search Service"
async function facetedProductSearch(searchTerm: string, facets: ProductFacets = {}) {
  const { categories, brands, priceRanges, ratings } = facets
  
  const baseConditions = [
    eq(products.status, 'active'), // [!code highlight]
    searchTerm ? or( // [!code highlight]
      like(products.name, `%${searchTerm}%`), // [!code highlight]
      like(products.description, `%${searchTerm}%`) // [!code highlight]
    ) : undefined // [!code highlight]
  ].filter(Boolean) // [!code highlight]
  
  // Apply facet filters
  if (categories?.length) {
    baseConditions.push(sql`${products.categoryId} = ANY(${categories})`) // [!code highlight]
  }
  
  if (brands?.length) {
    baseConditions.push(sql`${products.brandId} = ANY(${brands})`) // [!code highlight]
  }
  
  if (priceRanges?.length) {
    const priceConditions = priceRanges.map(range => // [!code highlight]
      between(products.price, range.min, range.max) // [!code highlight]
    ) // [!code highlight]
    baseConditions.push(or(...priceConditions)) // [!code highlight]
  }
  
  if (ratings?.length) {
    baseConditions.push(sql`${products.averageRating} = ANY(${ratings})`) // [!code highlight]
  }
  
  return await productService.findAll({
    custom: and(...baseConditions), // [!code highlight]
    relations: [
      {
        table: categories,
        type: 'inner',
        sql: eq(products.categoryId, categories.id)
      },
      {
        table: brands,
        type: 'inner',
        sql: eq(products.brandId, brands.id)
      }
    ],
    orderBy: { featured: 'desc', averageRating: 'desc' },
    parse: (data) => data.map(row => ({ // [!code highlight]
      ...row.products, // [!code highlight]
      category: row.categories, // [!code highlight]
      brand: row.brands // [!code highlight]
    })) // [!code highlight]
  })
}
```

## Performance Optimization Patterns

### Query Result Caching

Cache frequently accessed query results for better performance.

```typescript title="Cached Query Service"
class CachedQueryService {
  private cache = new Map<string, { data: any; expiry: number }>()
  
  async getCachedPosts(cacheKey: string, queryFn: () => Promise<any>, ttl = 300000) { // 5 minutes
    const cached = this.cache.get(cacheKey) // [!code highlight]
    
    if (cached && cached.expiry > Date.now()) { // [!code highlight]
      return cached.data // [!code highlight]
    } // [!code highlight]
    
    const data = await queryFn() // [!code highlight]
    
    this.cache.set(cacheKey, { // [!code highlight]
      data, // [!code highlight]
      expiry: Date.now() + ttl // [!code highlight]
    }) // [!code highlight]
    
    return data
  }
  
  clearCache(pattern?: string) { // [!code highlight]
    if (pattern) { // [!code highlight]
      for (const key of this.cache.keys()) { // [!code highlight]
        if (key.includes(pattern)) { // [!code highlight]
          this.cache.delete(key) // [!code highlight]
        } // [!code highlight]
      } // [!code highlight]
    } else { // [!code highlight]
      this.cache.clear() // [!code highlight]
    } // [!code highlight]
  } // [!code highlight]
}
```

### Batch Query Processing

Process multiple related queries efficiently.

```typescript title="Batch Query Service"
async function getUserDashboardData(userId: number) {
  // Execute multiple queries in parallel
  const [userProfile, recentOrders, favoriteProducts, notifications] = await Promise.all([
    // User profile with preferences
    userService.findById(userId, { // [!code highlight]
      relations: [{ // [!code highlight]
        table: userPreferences, // [!code highlight]
        type: 'left', // [!code highlight]
        sql: eq(users.id, userPreferences.userId) // [!code highlight]
      }] // [!code highlight]
    }), // [!code highlight]
    
    // Recent orders
    orderService.findBy( // [!code highlight]
      { userId }, // [!code highlight]
      { // [!code highlight]
        orderBy: { createdAt: 'desc' }, // [!code highlight]
        limit: 5 // [!code highlight]
      } // [!code highlight]
    ), // [!code highlight]
    
    // Favorite products
    favoriteService.findBy( // [!code highlight]
      { userId }, // [!code highlight]
      { // [!code highlight]
        relations: [{ // [!code highlight]
          table: products, // [!code highlight]
          type: 'inner', // [!code highlight]
          sql: eq(favorites.productId, products.id) // [!code highlight]
        }], // [!code highlight]
        limit: 10 // [!code highlight]
      } // [!code highlight]
    ), // [!code highlight]
    
    // Unread notifications
    notificationService.findBy( // [!code highlight]
      { userId, isRead: false }, // [!code highlight]
      { // [!code highlight]
        orderBy: { createdAt: 'desc' }, // [!code highlight]
        limit: 5 // [!code highlight]
      } // [!code highlight]
    ) // [!code highlight]
  ])
  
  return {
    profile: userProfile,
    orders: recentOrders,
    favorites: favoriteProducts,
    notifications
  }
}
```

<Callout type="info">
These examples demonstrate production-ready query patterns. Always consider your specific use case, data volume, and performance requirements when implementing similar patterns.
</Callout>

<Banner variant="success">
**Pro Tip:** Use TypeScript's strict mode and proper type definitions to catch query errors at compile time rather than runtime.
</Banner>
